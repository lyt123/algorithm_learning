/*
说明：这里的代码不够优雅，但确实跑通了所有测试用例了。这道题几行代码其实就可以搞定了。
总结：
1.写代码前把所有的测试用例写出来  以免代码写到一半才发现某些情况没有考虑比较尴尬  而且那时也没心情优化代码了
2.尽量分析下复杂度，复杂度太高的解法一般都不是面试的解法
3.不着急调试，自己把代码的运行过程在心中跑一遍，确认思路无误了，再去调试
*/

#include<iostream>
#include<vector>
using namespace std;
class Subsequence {
public:
	int shortestSubsequence(vector<int> A, int n)
	{
		int first_start_point = -1;
		int start_point = -1;
		int is_sorted = 1;
		int end_point = -1;
		int end_sequence_big_value = -1;
		int end_sequence_min_value = 0x7FFFFFFF;

		for (int i = 0; i < n - 1; i++) {
			if (is_sorted != 1) {
				if (A[i + 1] > A[start_point]) {
					is_sorted = 1;
					end_point = i + 1;
				}
				else {
					//记录一下后面的最大数
					end_sequence_big_value = (A[i + 1] > end_sequence_big_value) ? A[i + 1] : end_sequence_big_value;
				}
				end_sequence_min_value = (A[i] < end_sequence_min_value) ? A[i] : end_sequence_min_value;

			}
			else {
				if (A[i] > A[i + 1]) {
					if (start_point != -1 && first_start_point == -1) {
						first_start_point = start_point;
					}
					end_point = -1;
					start_point = i;
					is_sorted = 0;
				}
			}
		}

		if (start_point != -1) {
			if (first_start_point != -1) {
				start_point = first_start_point;
			}
			while (A[start_point] > end_sequence_min_value) {
				start_point--;
			}
			start_point++;
			if (end_point != -1) {
				return end_point - start_point;
			}
			else {
				while (A[start_point] > end_sequence_big_value) {
					start_point--;
				}
				return n - start_point;
			}
		}
		else {
			return 0;
		}
	}
};
int mainxxx()
{
	//int a[6] = { 1,4,6,5,9,10 };
	//vector<int> b(a, a + 6);

	//第一次代码通不过的用例
	//int a[6] = { 1, 2, 10, 1, 8, 9 };
	//vector<int> b(a, a + 6);

	//第二次通不过
	//int a[10] = { 1, 2, 143536, 65555, 265023, 105216, 204883, 268709, 303029, 303030 };
	//vector<int> b(a, a + 10);

	//第三次通不过
	int a[294] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,57828,235976,76198,81398,145670,43015,252327,101595,185281,144107,57189,75745,226019,102641,109470,232903,242870,296404,74797,125988,268544,48908,267283,74746,207479,61278,85901,169798,639,117587,15883,221882,59498,19761,100511,78973,247146,236019,96862,29789,258418,85717,102738,122337,164294,211218,57966,102275,87656,253142,301727,127212,226672,224822,266050,155162,165606,159347,225779,217303,49643,7135,38065,69868,94148,297612,212934,203619,58385,9757,262780,204481,199076,195534,77927,95669,250976,67750,197131,10867,137993,225778,289157,230721,292456,273580,250192,286213,264807,212299,136976,99714,147831,134298,253071,93249,230824,86297,128310,290515,64876,60494,229787,283330,12068,97779,13697,216676,118200,228337,95201,40029,22522,197524,55712,251489,149505,17747,258294,125822,240184,107224,236878,233652,247516,56735,156967,53249,298440,102825,101757,257851,191525,107856,208887,184675,76318,45082,287755,80066,158107,82094,255596,185393,228334,276767,163632,137377,136668,266756,107837,289814,145366,203067,37549,41579,158536,65552,2925,270030,144085,176392,167787,69743,79208,187004,113676,144408,127700,291263,188999,47582,221403,115385,126737,85824,187290,178290,280405,236186,1816,140991,233326,179071,253379,294550,112909,145598,67038,31197,143912,194822,166088,158368,135620,108459,262248,17465,133353,39975,291,114176,302985,302986,302987,302988,302989,302990,302991,302992,302993,302994,302995,302996,302997,302998,302999,303000,303001,303002,303003,303004,303005,303006,303007,303008,303009,303010,303011,303012,303013,303014,303015,303016,303017,303018,303019,303020,303021,303022,303023,303024,303025,303026,303027,303028,303029,303030 };
	vector<int> b(a, a + 294);

	Subsequence c;
	int d = c.shortestSubsequence(b, 294);
	cout << d << endl;
	system("pause");
	return 0;
}