/*
2018-7-24
说明：这里的代码不够优雅，但确实跑通了所有测试用例了。这道题几行代码其实就可以搞定了。
总结：
1.写代码前把所有的测试用例写出来  以免代码写到一半才发现某些情况没有考虑比较尴尬  而且那时也没心情优化代码了
2.尽量分析下复杂度，复杂度太高的解法一般都不是面试的解法
3.不着急调试，自己把代码的运行过程在心中跑一遍，确认思路无误了，再去调试
2018-9-3
这次我写代码前把几个可能出现的情况都列出来了，“然后采用了从末尾开始遍历的方法”，但最终代码写完在测试时发现从末尾和从头是没差别的。。。
这个时候才回忆起该遍历两次，很快就写出来代码了
总结
1.不要陷入细节，想好方法最重要
*/

#include<iostream>
#include<vector>
using namespace std;
class Subsequence {
public:
	//以前的解法2018-7-24
	int shortestSubsequence0(vector<int> A, int n)
	{
		int first_start_point = -1;
		int start_point = -1;
		int is_sorted = 1;
		int end_point = -1;
		int end_sequence_big_value = -1;
		int end_sequence_min_value = 0x7FFFFFFF;

		for (int i = 0; i < n - 1; i++) {
			if (is_sorted != 1) {
				if (A[i + 1] > A[start_point]) {
					is_sorted = 1;
					end_point = i + 1;
				}
				else {
					//记录一下后面的最大数
					end_sequence_big_value = (A[i + 1] > end_sequence_big_value) ? A[i + 1] : end_sequence_big_value;
				}
				end_sequence_min_value = (A[i] < end_sequence_min_value) ? A[i] : end_sequence_min_value;

			}
			else {
				if (A[i] > A[i + 1]) {
					if (start_point != -1 && first_start_point == -1) {
						first_start_point = start_point;
					}
					end_point = -1;
					start_point = i;
					is_sorted = 0;
				}
			}
		}

		if (start_point != -1) {
			if (first_start_point != -1) {
				start_point = first_start_point;
			}
			while (A[start_point] > end_sequence_min_value) {
				start_point--;
			}
			start_point++;
			if (end_point != -1) {
				return end_point - start_point;
			}
			else {
				while (A[start_point] > end_sequence_big_value) {
					start_point--;
				}
				return n - start_point;
			}
		}
		else {
			return 0;
		}
	}

	//现在的解法2018-9-3
	//测试用例
	//[1,4,6,5,9,10]
	//[1,12,2,8,4,6,5,9,10,15,18]
	//[1,19,2,8,4,6,5,9,10,15,18]  这种情况麻烦 case 3
	//[1,5,9,6,12,19,2,8,4,6,5,9,10,15,18]
	//[1,5,9,6,12,19,2,8,4,6,5,9,10,15,18]  注意5大于后面的4。。。
	int shortestSubsequence1(vector<int> A, int n)
	{
		int max_value_index = -1;
		int shortest_len = 0;
		//int max_value = -1;
		for (int i = A.size() - 2; i >= 0; i--) {
			//max_value = (max_value_index == -1) ? A[i + 1] : A[max_value_index];
			if (A[i] > A[i + 1]) {
				int j = (max_value_index == -1) ? (i + 2) : max_value_index;
				while ((A[i] > A[j]) && (j <= A.size() - 2))
					j++;
				if (j == A.size() - 1 && A[i] > A[j]) {
					//处理case 3
					swap(A[i], A[j]);
					shortest_len = max_value_index - i + 1;//要再加1
				}
				else {
					shortest_len = max_value_index - i;
				}
				max_value_index = j;
			}
		}
		return shortest_len;
	}

	//正确的解法应该是遍历两次->转移注意力  找到最靠左和最靠右应该调整的数
	//1,5,9,6,12,19,2,8,4,6,5,9,10,15,18
	int shortestSubsequence(vector<int> A, int n)
	{
		int max = A[0], target_right_index = -1;
		for (int i = 1; i <= n - 1; i++) {
			if (A[i] > max) {
				max = A[i];
			}
			else if (A[i] < max) {
				target_right_index = i;
			}
			else {
				//target_right_index = i-1;
			}
		}
		int min = A[n - 1], target_left_index = -1;
		for (int i = n - 2; i >= 0; i--) {
			//找出右边最小的数，不断记录它左边比他大的数的index
			if (A[i] < min) {  //相等的情况不考虑
				min = A[i];
			}
			else if (A[i] > min) {
				target_left_index = i;
			}
			else {
				//target_left_index = i+1;
			}
		}
		if (target_left_index == -1 && target_right_index == -1)
			return 0;

		return target_right_index - target_left_index + 1;
	}
};
int mainseq()
{
	//以前的测试
	//int a[6] = { 1,4,6,5,9,10 };
	//vector<int> b(a, a + 6);

	//第一次代码通不过的用例
	//int a[6] = { 1, 2, 10, 1, 8, 9 };
	//vector<int> b(a, a + 6);

	//第二次通不过
	//int a[10] = { 1, 2, 143536, 65555, 265023, 105216, 204883, 268709, 303029, 303030 };
	//vector<int> b(a, a + 10);

	//第三次通不过
	//int a[294] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,57828,235976,76198,81398,145670,43015,252327,101595,185281,144107,57189,75745,226019,102641,109470,232903,242870,296404,74797,125988,268544,48908,267283,74746,207479,61278,85901,169798,639,117587,15883,221882,59498,19761,100511,78973,247146,236019,96862,29789,258418,85717,102738,122337,164294,211218,57966,102275,87656,253142,301727,127212,226672,224822,266050,155162,165606,159347,225779,217303,49643,7135,38065,69868,94148,297612,212934,203619,58385,9757,262780,204481,199076,195534,77927,95669,250976,67750,197131,10867,137993,225778,289157,230721,292456,273580,250192,286213,264807,212299,136976,99714,147831,134298,253071,93249,230824,86297,128310,290515,64876,60494,229787,283330,12068,97779,13697,216676,118200,228337,95201,40029,22522,197524,55712,251489,149505,17747,258294,125822,240184,107224,236878,233652,247516,56735,156967,53249,298440,102825,101757,257851,191525,107856,208887,184675,76318,45082,287755,80066,158107,82094,255596,185393,228334,276767,163632,137377,136668,266756,107837,289814,145366,203067,37549,41579,158536,65552,2925,270030,144085,176392,167787,69743,79208,187004,113676,144408,127700,291263,188999,47582,221403,115385,126737,85824,187290,178290,280405,236186,1816,140991,233326,179071,253379,294550,112909,145598,67038,31197,143912,194822,166088,158368,135620,108459,262248,17465,133353,39975,291,114176,302985,302986,302987,302988,302989,302990,302991,302992,302993,302994,302995,302996,302997,302998,302999,303000,303001,303002,303003,303004,303005,303006,303007,303008,303009,303010,303011,303012,303013,303014,303015,303016,303017,303018,303019,303020,303021,303022,303023,303024,303025,303026,303027,303028,303029,303030 };
	//vector<int> b(a, a + 294);

	//现在的测试
	//[1,4,6,5,9,10]
	//[1,12,2,8,4,6,5,9,10,15,18]
	//[1,19,2,8,4,6,5,9,10,15,18]
	//[1,5,9,6,12,19,2,8,4,6,5,9,10,15,18]
	//vector<int> b = { 1,4,6,5,9,10 };
	//vector<int> b = { 1,12,2,8,4,6,5,9,10,15,18 };
	//vector<int> b = { 1,19,2,8,4,6,5,9,10,15,18 };
	vector<int> b = { 1,5,9,6,12,19,2,8,4,6,5,9,10,15,18 };

	Subsequence c;
	int d = c.shortestSubsequence(b, 11);
	cout << d << endl;
	system("pause");
	return 0;
}
/*
题目描述：
对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。

给定一个int数组A和数组的大小n，请返回一个二元组，代表所求序列的长度。(原序列位置从0开始标号,若原序列有序，返回0)。保证A中元素均为正整数。

测试样例：
[1,4,6,5,9,10],6
返回：2
*/